?package game.utils.zip
{
    import flash.utils.*;

    public class ZipFile extends Object
    {
        private var entryTable:Dictionary;
        private var entryList:Array;
        private var buf:ByteArray;
        private var locOffsetTable:Dictionary;

        public function ZipFile(param1:IDataInput)
        {
            buf = new ByteArray();
            buf.endian = Endian.LITTLE_ENDIAN;
            param1.readBytes(buf);
            readEntries();
            return;
        }// end function

        public function get size() : uint
        {
            return entryList.length;
        }// end function

        private function findEND() : uint
        {
            var _loc_1:* = buf.length - ZipConstants.ENDHDR;
            var _loc_2:* = Math.max(0, _loc_1 - 65535);
            while (_loc_1 >= _loc_2)
            {
                
                if (buf[_loc_1] != 80)
                {
                }
                else
                {
                    buf.position = _loc_1;
                    if (buf.readUnsignedInt() == ZipConstants.ENDSIG)
                    {
                        return _loc_1;
                    }
                }
                _loc_1 = _loc_1 - 1;
            }
            throw new ZipError("invalid zip");
        }// end function

        private function readEND() : void
        {
            var _loc_1:* = new ByteArray();
            _loc_1.endian = Endian.LITTLE_ENDIAN;
            buf.position = findEND();
            buf.readBytes(_loc_1, 0, ZipConstants.ENDHDR);
            _loc_1.position = ZipConstants.ENDTOT;
            entryList = new Array(_loc_1.readUnsignedShort());
            _loc_1.position = ZipConstants.ENDOFF;
            buf.position = _loc_1.readUnsignedInt();
            return;
        }// end function

        private function readEntries() : void
        {
            var _loc_2:ByteArray = null;
            var _loc_3:uint = 0;
            var _loc_4:ZipEntry = null;
            readEND();
            entryTable = new Dictionary();
            locOffsetTable = new Dictionary();
            var _loc_1:uint = 0;
            while (_loc_1 < entryList.length)
            {
                
                _loc_2 = new ByteArray();
                _loc_2.endian = Endian.LITTLE_ENDIAN;
                buf.readBytes(_loc_2, 0, ZipConstants.CENHDR);
                if (_loc_2.readUnsignedInt() != ZipConstants.CENSIG)
                {
                    throw new ZipError("invalid CEN header (bad signature)");
                }
                _loc_2.position = ZipConstants.CENNAM;
                _loc_3 = _loc_2.readUnsignedShort();
                if (_loc_3 == 0)
                {
                    throw new ZipError("missing entry name");
                }
                _loc_4 = new ZipEntry(buf.readMultiByte(_loc_3, "gb2312"));
                _loc_3 = _loc_2.readUnsignedShort();
                _loc_4.extra = new ByteArray();
                if (_loc_3 > 0)
                {
                    buf.readBytes(_loc_4.extra, 0, _loc_3);
                }
                buf.position = buf.position + _loc_2.readUnsignedShort();
                _loc_2.position = ZipConstants.CENVER;
                _loc_4.version = _loc_2.readUnsignedShort();
                _loc_4.flag = _loc_2.readUnsignedShort();
                if ((_loc_4.flag & 1) == 1)
                {
                    throw new ZipError("encrypted ZIP entry not supported");
                }
                _loc_4.method = _loc_2.readUnsignedShort();
                _loc_4.dostime = _loc_2.readUnsignedInt();
                _loc_4.crc = _loc_2.readUnsignedInt();
                _loc_4.compressedSize = _loc_2.readUnsignedInt();
                _loc_4.size = _loc_2.readUnsignedInt();
                entryList[_loc_1] = _loc_4;
                entryTable[_loc_4.name] = _loc_4;
                _loc_2.position = ZipConstants.CENOFF;
                locOffsetTable[_loc_4.name] = _loc_2.readUnsignedInt();
                _loc_1 = _loc_1 + 1;
            }
            return;
        }// end function

        public function getInput(param1:ZipEntry) : ByteArray
        {
            var _loc_5:ByteArray = null;
            var _loc_6:Inflater = null;
            buf.position = locOffsetTable[param1.name] + ZipConstants.LOCHDR - 2;
            var _loc_2:* = buf.readShort();
            var _loc_3:* = new ByteArray();
            _loc_3.writeMultiByte(param1.name, "gb2312");
            buf.position = buf.position + (_loc_3.length + _loc_2);
            var _loc_4:* = new ByteArray();
            if (param1.compressedSize > 0)
            {
                buf.readBytes(_loc_4, 0, param1.compressedSize);
            }
            switch(param1.method)
            {
                case ZipConstants.STORED:
                {
                    return _loc_4;
                }
                case ZipConstants.DEFLATED:
                {
                    _loc_5 = new ByteArray();
                    _loc_6 = new Inflater();
                    _loc_6.setInput(_loc_4);
                    _loc_6.inflate(_loc_5);
                    return _loc_5;
                }
                default:
                {
                    throw new ZipError("invalid compression method");
                    break;
                }
            }
        }// end function

        public function get entries() : Array
        {
            return entryList;
        }// end function

        public function getEntry(param1:String) : ZipEntry
        {
            return entryTable[param1];
        }// end function

    }
}
